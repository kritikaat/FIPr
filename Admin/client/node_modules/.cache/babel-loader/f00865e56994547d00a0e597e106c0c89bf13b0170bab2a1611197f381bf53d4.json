{"ast":null,"code":"'use strict';\n\nconst os = require('os');\nconst lodashGet = require('lodash.get');\nconst {\n  getProp\n} = require('./utils');\nconst defaultFormatter = require('./formatters/default');\nconst numberFormatterCtor = require('./formatters/number');\nconst stringFormatterCtor = require('./formatters/string');\nconst symbolFormatterCtor = require('./formatters/symbol');\nconst objectFormatterCtor = require('./formatters/object');\nclass JSON2CSVBase {\n  constructor(opts) {\n    this.opts = this.preprocessOpts(opts);\n  }\n\n  /**\r\n   * Check passing opts and set defaults.\r\n   *\r\n   * @param {Json2CsvOptions} opts Options object containing fields,\r\n   * delimiter, default value, quote mark, header, etc.\r\n   */\n  preprocessOpts(opts) {\n    const processedOpts = Object.assign({}, opts);\n    if (processedOpts.fields) {\n      processedOpts.fields = this.preprocessFieldsInfo(processedOpts.fields, processedOpts.defaultValue);\n    }\n    processedOpts.transforms = processedOpts.transforms || [];\n    const stringFormatter = processedOpts.formatters && processedOpts.formatters['string'] || stringFormatterCtor();\n    const objectFormatter = objectFormatterCtor({\n      stringFormatter\n    });\n    const defaultFormatters = {\n      header: stringFormatter,\n      undefined: defaultFormatter,\n      boolean: defaultFormatter,\n      number: numberFormatterCtor(),\n      bigint: defaultFormatter,\n      string: stringFormatter,\n      symbol: symbolFormatterCtor({\n        stringFormatter\n      }),\n      function: objectFormatter,\n      object: objectFormatter\n    };\n    processedOpts.formatters = {\n      ...defaultFormatters,\n      ...processedOpts.formatters\n    };\n    processedOpts.delimiter = processedOpts.delimiter || ',';\n    processedOpts.eol = processedOpts.eol || os.EOL;\n    processedOpts.header = processedOpts.header !== false;\n    processedOpts.includeEmptyRows = processedOpts.includeEmptyRows || false;\n    processedOpts.withBOM = processedOpts.withBOM || false;\n    return processedOpts;\n  }\n\n  /**\r\n   * Check and normalize the fields configuration.\r\n   *\r\n   * @param {(string|object)[]} fields Fields configuration provided by the user\r\n   * or inferred from the data\r\n   * @returns {object[]} preprocessed FieldsInfo array\r\n   */\n  preprocessFieldsInfo(fields, globalDefaultValue) {\n    return fields.map(fieldInfo => {\n      if (typeof fieldInfo === 'string') {\n        return {\n          label: fieldInfo,\n          value: fieldInfo.includes('.') || fieldInfo.includes('[') ? row => lodashGet(row, fieldInfo, globalDefaultValue) : row => getProp(row, fieldInfo, globalDefaultValue)\n        };\n      }\n      if (typeof fieldInfo === 'object') {\n        const defaultValue = 'default' in fieldInfo ? fieldInfo.default : globalDefaultValue;\n        if (typeof fieldInfo.value === 'string') {\n          return {\n            label: fieldInfo.label || fieldInfo.value,\n            value: fieldInfo.value.includes('.') || fieldInfo.value.includes('[') ? row => lodashGet(row, fieldInfo.value, defaultValue) : row => getProp(row, fieldInfo.value, defaultValue)\n          };\n        }\n        if (typeof fieldInfo.value === 'function') {\n          const label = fieldInfo.label || fieldInfo.value.name || '';\n          const field = {\n            label,\n            default: defaultValue\n          };\n          return {\n            label,\n            value(row) {\n              const value = fieldInfo.value(row, field);\n              return value === null || value === undefined ? defaultValue : value;\n            }\n          };\n        }\n      }\n      throw new Error('Invalid field info option. ' + JSON.stringify(fieldInfo));\n    });\n  }\n\n  /**\r\n   * Create the title row with all the provided fields as column headings\r\n   *\r\n   * @returns {String} titles as a string\r\n   */\n  getHeader(fields) {\n    return fields.map(fieldInfo => this.opts.formatters.header(fieldInfo.label)).join(this.opts.delimiter);\n  }\n\n  /**\r\n   * Preprocess each object according to the given transforms (unwind, flatten, etc.).\r\n   * @param {Object} row JSON object to be converted in a CSV row\r\n   */\n  preprocessRow(row) {\n    return this.opts.transforms.reduce((rows, transform) => rows.flatMap(row => transform(row)), [row]);\n  }\n\n  /**\r\n   * Create the content of a specific CSV row\r\n   *\r\n   * @param {Object} row JSON object to be converted in a CSV row\r\n   * @returns {String} CSV string (row)\r\n   */\n  processRow(row, fields) {\n    if (!row) {\n      return undefined;\n    }\n    const processedRow = fields.map(fieldInfo => this.processCell(row, fieldInfo));\n    if (!this.opts.includeEmptyRows && processedRow.every(field => field === '')) {\n      return undefined;\n    }\n    return processedRow.join(this.opts.delimiter);\n  }\n\n  /**\r\n   * Create the content of a specfic CSV row cell\r\n   *\r\n   * @param {Object} row JSON object representing the  CSV row that the cell belongs to\r\n   * @param {FieldInfo} fieldInfo Details of the field to process to be a CSV cell\r\n   * @returns {String} CSV string (cell)\r\n   */\n  processCell(row, fieldInfo) {\n    return this.processValue(fieldInfo.value(row));\n  }\n\n  /**\r\n   * Create the content of a specfic CSV row cell\r\n   *\r\n   * @param {Any} value Value to be included in a CSV cell\r\n   * @returns {String} Value stringified and processed\r\n   */\n  processValue(value) {\n    return this.opts.formatters[typeof value](value);\n  }\n}\nmodule.exports = JSON2CSVBase;","map":{"version":3,"names":["os","require","lodashGet","getProp","defaultFormatter","numberFormatterCtor","stringFormatterCtor","symbolFormatterCtor","objectFormatterCtor","JSON2CSVBase","constructor","opts","preprocessOpts","processedOpts","Object","assign","fields","preprocessFieldsInfo","defaultValue","transforms","stringFormatter","formatters","objectFormatter","defaultFormatters","header","undefined","boolean","number","bigint","string","symbol","function","object","delimiter","eol","EOL","includeEmptyRows","withBOM","globalDefaultValue","map","fieldInfo","label","value","includes","row","default","name","field","Error","JSON","stringify","getHeader","join","preprocessRow","reduce","rows","transform","flatMap","processRow","processedRow","processCell","every","processValue","module","exports"],"sources":["C:/Users/kruti/Downloads/FIPr/Admin/client/node_modules/json2csv/lib/JSON2CSVBase.js"],"sourcesContent":["'use strict';\r\n\r\nconst os = require('os');\r\nconst lodashGet = require('lodash.get');\r\nconst { getProp } = require('./utils');\r\nconst defaultFormatter = require('./formatters/default');\r\nconst numberFormatterCtor = require('./formatters/number')\r\nconst stringFormatterCtor = require('./formatters/string');\r\nconst symbolFormatterCtor = require('./formatters/symbol');\r\nconst objectFormatterCtor = require('./formatters/object');\r\n\r\nclass JSON2CSVBase {\r\n  constructor(opts) {\r\n    this.opts = this.preprocessOpts(opts);\r\n  }\r\n\r\n  /**\r\n   * Check passing opts and set defaults.\r\n   *\r\n   * @param {Json2CsvOptions} opts Options object containing fields,\r\n   * delimiter, default value, quote mark, header, etc.\r\n   */\r\n  preprocessOpts(opts) {\r\n    const processedOpts = Object.assign({}, opts);\r\n\r\n    if (processedOpts.fields) {\r\n      processedOpts.fields = this.preprocessFieldsInfo(processedOpts.fields, processedOpts.defaultValue);\r\n    }\r\n\r\n    processedOpts.transforms = processedOpts.transforms || [];\r\n\r\n    const stringFormatter = (processedOpts.formatters && processedOpts.formatters['string']) || stringFormatterCtor();\r\n    const objectFormatter = objectFormatterCtor({ stringFormatter });    \r\n    const defaultFormatters = {\r\n      header: stringFormatter,\r\n      undefined: defaultFormatter,\r\n      boolean: defaultFormatter,\r\n      number: numberFormatterCtor(),\r\n      bigint: defaultFormatter,\r\n      string: stringFormatter,\r\n      symbol: symbolFormatterCtor({ stringFormatter }),\r\n      function: objectFormatter,\r\n      object: objectFormatter\r\n    };\r\n\r\n    processedOpts.formatters = {\r\n      ...defaultFormatters,\r\n      ...processedOpts.formatters,\r\n    };\r\n\r\n    processedOpts.delimiter = processedOpts.delimiter || ',';\r\n    processedOpts.eol = processedOpts.eol || os.EOL;\r\n    processedOpts.header = processedOpts.header !== false;\r\n    processedOpts.includeEmptyRows = processedOpts.includeEmptyRows || false;\r\n    processedOpts.withBOM = processedOpts.withBOM || false;\r\n\r\n    return processedOpts;\r\n  }\r\n\r\n  /**\r\n   * Check and normalize the fields configuration.\r\n   *\r\n   * @param {(string|object)[]} fields Fields configuration provided by the user\r\n   * or inferred from the data\r\n   * @returns {object[]} preprocessed FieldsInfo array\r\n   */\r\n  preprocessFieldsInfo(fields, globalDefaultValue) {\r\n    return fields.map((fieldInfo) => {\r\n      if (typeof fieldInfo === 'string') {\r\n        return {\r\n          label: fieldInfo,\r\n          value: (fieldInfo.includes('.') || fieldInfo.includes('['))\r\n            ? row => lodashGet(row, fieldInfo, globalDefaultValue)\r\n            : row => getProp(row, fieldInfo, globalDefaultValue),\r\n        };\r\n      }\r\n\r\n      if (typeof fieldInfo === 'object') {\r\n        const defaultValue = 'default' in fieldInfo\r\n          ? fieldInfo.default\r\n          : globalDefaultValue;\r\n\r\n        if (typeof fieldInfo.value === 'string') {\r\n          return {\r\n            label: fieldInfo.label || fieldInfo.value,\r\n            value: (fieldInfo.value.includes('.') || fieldInfo.value.includes('['))\r\n              ? row => lodashGet(row, fieldInfo.value, defaultValue)\r\n              : row => getProp(row, fieldInfo.value, defaultValue),\r\n          };\r\n        }\r\n\r\n        if (typeof fieldInfo.value === 'function') {\r\n          const label = fieldInfo.label || fieldInfo.value.name || '';\r\n          const field = { label, default: defaultValue };\r\n          return {\r\n            label,\r\n            value(row) {\r\n              const value = fieldInfo.value(row, field);\r\n              return (value === null || value === undefined)\r\n                ? defaultValue\r\n                : value;\r\n            },\r\n          }\r\n        }\r\n      }\r\n\r\n      throw new Error('Invalid field info option. ' + JSON.stringify(fieldInfo));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Create the title row with all the provided fields as column headings\r\n   *\r\n   * @returns {String} titles as a string\r\n   */\r\n  getHeader(fields) {\r\n    return fields\r\n      .map(fieldInfo => this.opts.formatters.header(fieldInfo.label))\r\n      .join(this.opts.delimiter);\r\n  }\r\n\r\n  /**\r\n   * Preprocess each object according to the given transforms (unwind, flatten, etc.).\r\n   * @param {Object} row JSON object to be converted in a CSV row\r\n   */\r\n  preprocessRow(row) {\r\n    return this.opts.transforms.reduce((rows, transform) =>\r\n      rows.flatMap(row => transform(row)),\r\n      [row]\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Create the content of a specific CSV row\r\n   *\r\n   * @param {Object} row JSON object to be converted in a CSV row\r\n   * @returns {String} CSV string (row)\r\n   */\r\n  processRow(row, fields) {\r\n    if (!row) {\r\n      return undefined;\r\n    }\r\n\r\n    const processedRow = fields.map(fieldInfo => this.processCell(row, fieldInfo));\r\n\r\n    if (!this.opts.includeEmptyRows && processedRow.every(field => field === '')) {\r\n      return undefined;\r\n    }\r\n\r\n    return processedRow.join(this.opts.delimiter);\r\n  }\r\n\r\n  /**\r\n   * Create the content of a specfic CSV row cell\r\n   *\r\n   * @param {Object} row JSON object representing the  CSV row that the cell belongs to\r\n   * @param {FieldInfo} fieldInfo Details of the field to process to be a CSV cell\r\n   * @returns {String} CSV string (cell)\r\n   */\r\n  processCell(row, fieldInfo) {\r\n    return this.processValue(fieldInfo.value(row));\r\n  }\r\n\r\n  /**\r\n   * Create the content of a specfic CSV row cell\r\n   *\r\n   * @param {Any} value Value to be included in a CSV cell\r\n   * @returns {String} Value stringified and processed\r\n   */\r\n  processValue(value) {\r\n    return this.opts.formatters[typeof value](value);\r\n  }\r\n}\r\n\r\nmodule.exports = JSON2CSVBase;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}